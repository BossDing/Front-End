# Front-End
## 前端开发工程师面试宝典！             [![AppVeyor](https://img.shields.io/badge/%E6%89%AB%E5%9C%B0-%E5%83%A7-green.svg?style=plastic)](https://weibo.com/237800789)   

## <a name='preface'>前言</a>

```
本仓库是我整理的一些常见的前端书籍以及网址，部分资料也参考了别人总结的网址，感谢！   
如有部分资料侵权，请及时联系我，本资料仅供大家学习参考使用！欢迎大家Star和提交issues。

```
NO.1  [前端书籍开发推荐](https://github.com/famensaodiseng/Front-End/edit/master/README.md)   
NO.2  [前端笔记版本第一部](https://github.com/famensaodiseng/Front-End/blob/master/%E5%89%8D%E7%AB%AF%E6%B4%97%E5%89%AA%E5%90%B9%E7%AC%94%E8%AE%B0.md)   
NO.3  [前端笔记版本第二部](https://github.com/famensaodiseng/Front-End/blob/master/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93.md)



#javascript的typeof返回那些数据类型？
	Object number function boolean underfind
# 例举3种强制类型转换和2种隐式类型转换?
	强制（parseInt,parseFloat,number）
	隐式（== – ===）
# split() join() 的区别
	前者是切割成数组的形式，后者是将数组转换成字符串	
# IE和DOM事件流的区别
	1.执行顺序不一样、
	2.参数不一样
		事件侦听函数的区别
			ie-->attachEvent('事件',事件处理函数);//两个参数
			DOM-->addEventListener('事件'，事件处理函数,boolean);//三个参数			
	3.事件加不加on
	4.this指向问题	
		事件绑定：addEventListener 
		与attachEvent  事件处理函数中this指向不同， IE中指向window
	5 ie 捕获 html>div>button
	  dom 先捕获 在 冒泡  html>div>button>div>html	

#call和apply的区别
	相同: call和apply 都是为了改变函数体内this的指向的。
	不同：接收参数的方式
	
	apply ↓↓↓
		function.apply(obj,args)方法能接收两个参数
		第一个参数  就是this的指向   这个对象代替Function类里的this对象
		args：这个数组或类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。
		
	call ↓↓↓
		call和apply方法的第一个参数是一样的，都是this的指向  功能和this想同
		call的第二个参数是参数列表
		
		在非严格模式下当我们第一个参数传递为null或undefined时，函数体的this会指向默认的宿主对象，
		在浏览器中则是window
		
		var test = function(){
		console.log(this === window);
		}
		test.apply(null);//true
		test.call(undefined);//true
		
	用法↓↓↓
		劫持别人的方法↓
		var foo = {
				name: "mingming",
				logName: function() {
					console.log(this.name);
				}
			}
			var bar = {
				name: "xiaowang"
			};
			foo.logName.call(bar); //xiaowang
			本身 this.name应该是foo对象的 name所对应的mingming，
			但是现在被call挟持了偷偷定义了一个bar 让this指向bar
			这样foo.logName.call(bar);就对应了bar中的Name
			
	实现继承↓
		function chinese() {
            person.call(this); //继承自 person 类 （用chinese来代替person）
 
            this.ch = function () {
                alert("我是中国人");
            }
        }
 
 
        function japanese() {
            animal.call(this); //继承自 animal 类
            person.call(this); //继承自 person 类
 
            this.ja = function () {
                alert("我是日本人");
            }
        }
 

# 事件委托是什么
	让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！
	案例: 为ui添加li 后添加的li没有事件 
		
		<ul id="ul">
			<li>aaaaaaaa</li>
			<li>bbbbbbbb</li>
			<li>cccccccc</li>
		</ul>
		<input type="button" id="btn" />
		
		window.onload = function(){
			var oUl = document.getElementById("ul");
			var aLi = oUl.getElementsByTagName("li");
			var oBtn = document.getElementById("btn");
			var iNow = 4;
			for(var i=0; i<aLi.length; i++){
				aLi[i].onmouseover = function(){
					this.style.background = "red";
				}
				aLi[i].onmouseout = function(){
					this.style.background = "";
				}
			}
			
			oBtn.onclick = function(){
				iNow ++;
				var oLi = document.createElement("li");
				oLi.innerHTML = 1111 *iNow;
				oUl.appendChild(oLi);
				
				//var olis = document.querySelectorAll("ul>li");
				//for(var i=0; i<olis.length; i++){
				//	olis[i].onmouseover = function(){
				//		this.style.background = "red";
				//	}
				//	olis[i].onmouseout = function(){
				//		this.style.background = "";
				//	}
				//}
			}
			
			//ie：window.event.srcElement
			//标准下:event.target
			oUl.onmouseover = function(ev){
				console.log(ev);
				var ev = ev || window.event;
				var target = ev.target || ev.srcElement;
				console.log(target);
				if(target.localName == "li"){
					target.style.background = "red";
				}
			}
			oUl.onmouseout = function(ev){
				var ev = ev || window.event;
				var target = ev.target || ev.srcElement;
				if(target.nodeName.toLowerCase() == "li"){
					target.style.background = "";
				}
			}
		}

# 如何阻止事件冒泡和默认事件
	阻止事件冒泡：
		stopPropagation()
		concelBubble = true	 //ie用
	为了兼容  
		封装一个stopBubble();
		判断浏览器 是否  有  stopPropagation()这个方法
		如果有就调用 stopPropagation();
		如果不存在  就  调用ie的concelBubble = “true”方法;
	
	阻止默认事件：
		proventDefault()
		returnValue()  //ie用
		
	为了兼容：
		封装一个 	stopDefault();
		判断浏览器  是否 有  proventDefalut()这个方法
		如果有就调用  proventDefalut();
		如果没有就使用ie的  returnValue = “false”；
		
		
		
		
	canceBubble return false
	// 停止事件冒泡
	function stopBubble(e) {
	    // 如果提供了事件对象，则这是一个非IE浏览器
	    if ( e && e.stopPropagation ) {
	    //如果e有值，并且e有stopPropagation这个属性，
	           则调用e.stopPropagation()

	        // 因此它支持W3C的stopPropagation()方法 
	        e.stopPropagation();
	    } else { 
	        // 否则，我们需要使用IE的方式来取消事件冒泡
	        window.event.cancelBubble = true;
	    }
	}    
	// 阻止事件默认行为
	function stopDefault( e ) {
	     // 阻止默认浏览器动作(W3C)
	     if ( e && e.preventDefault ) {
	         e.preventDefault();
	     } else {
	        // IE中阻止函数器默认动作的方式
	        window.event.returnValue = false;
	    }
	    return false;#如何阻止事件的冒泡和默认事件

# 闭包是什么，有什么特性，对页面有什么影响
	闭包: 闭包的实质是一个函数，是一个用于返回局部变量值的函数，
	闭包特性 : 是能够读取其他函数内部变量的函数 因为在全局中，受JavaScript链式作用域结构的影响，父级变量中无法访问到子级的变量值，为了解决这个问题，才使用闭包这个概念。
	影响: 由于闭包时，变量的值都保存到内存中，会导致页面加载时内存消耗很大，IE会导致内在泄露，因此尽量少用或用时要及时删除变量。
	例如:
		//问题代码	
		for(var i = 0 ; i < 10; i++){
          setTimeout(function(){
              console.log(i);
          },0);
      	}
        //闭包解决问题的代码
        for(var i = 0; i< 3; i++){
            function foo(j){
                return function(){
                    console.log(j);
                };
            }
            var f = foo(i);
            setTimeout(f, 0);
        }

#doccument load 和  document ready的区别
	1.load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行一个函数
		问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响
	2.$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行
		在原生的jS中不包括ready()这个方法，只有load方法就是onload事件

# ajax请求的时候get 和post方式的区别
	1 使用Get请求时,参数在URL中显示,而使用Post方式,则不会显示出来
	2 使用Get请求发送数据量小,Post请求发送数据量大
	查看这个地址具体使用:http://www.cnblogs.com/oneword/archive/2011/06/06/2073533.html

# ”==”和“===”的不同
	==: 比较值是否相同      前者会自动转换类型
	===: 比较值与数据类型是否相同     后者不会

#JavaScript 的数据类型都有什么？
	1 Number 数字类型
	2 String 字符串类型
	3 Boolean 布尔类型
	4 Function 函数
	5 Object 对象
	6 Null
	7 Undefined 没有定义类型

#Javascript 中 callee 和 caller 的作用？
	相同: 都是arguments的一个属性
	不同: 
		caller: 返回一个函数的引用，这个函数调用了当前的函数; 返回正在执行的函数本身的引用
		注意:
			1 这个属性只有当函数在执行时才有用
			2 如果在JavaScript程序中，函数是由顶层调用的，则返回null functionName.caller: functionName是当前正在执行的函数。
			var a = function() {   
				alert(a.caller);   
			}   
			var b = function() {   
				a();   
			}   
			b(); 
			//上面的代码中，b调用了a，那么a.caller返回的是b的引用，结果如下:
				var b = function() {   
					a();   
				} 
				
		callee: 放回正在执行的函数本身的引用
		注意:
			1 这个属性只有在函数执行时才有效
			2 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于
			3 它可以用来递归匿名函数
			var a = function() {   
				alert(arguments.callee);   
			}   
			var b = function() {   
				a();   
			}   
			b(); 
			//a在b中被调用，但是它返回了a本身的引用，结果如下:
				var a = function() {   
					alert(arguments.callee);   
				}   

#简述列举文档对像模型BOM里document 的常用 的查找访问节点 的方法 并作简单 的 说明
	1 通过ID,使用 getElementById() 获得标签节点
	2 通过标签的名称,使用getElementsByTagName() 获得元素节点或标签节点
		注意：以上的查找方式都会忽略文档的结构
	3 通过使用一个元素节点的 parentNode、firstChild 以及 lastChild 属性
	4 节点名称nodeName
		a) 如果节点是标签，nodeName是标签名称
		b) 如果节点是属性，nodeName是属性名称
		c) 如果节点是文本节点，nodeName是#text
		d) 如果节点是文档，nodeName是#document
	5 节点值nodeValue
	6 节点类型nodeType

#简述创建函数的几种方式
	1 函数声明
		:解析器会先读取函数声明，并使其在执行任何代码之前可以访问
		function sum1(n1,n2){
		    return n1+n2;
		};
	
	2 函数表达式，又叫函数字面量	
		:函数表达式则必须等到解析器执行到它所在的代码行才会真正被解释执行
		var sum2=function(n1,n2){
		    return n1+n2;
		};
		
	3 自执行函数严格来说也叫函数表达式
		:创建一个新的作用域，且立即执行,在此作用域内声明的变量，不会和其它作用域内的变量冲突或混淆，大多是以匿名函数方式存在	
		(function(n1,n2){
    		console.log (n1+n2)
		})(1,3);//4
 
#JavaScript如何实现继承？
	种类:六种  记住前三种 后面三种 记住名称就行
	
		既然要实现继承，那么首先我们得有一个父类，代码如下：
		//定义一个动物类
		function Animal (name) {
		  this.name = name || 'Animal'; // 属性
		  this.sleep = function(){ // 实例方法
		    console.log(this.name + '正在睡觉！');
		  }
		}
		// 原型方法
		Animal.prototype.eat = function(food) {
		  console.log(this.name + '正在吃：' + food);
		};
		
	一 原型链继承(推荐★★ 3 4两大致命缺陷)
		核心: 将父类的实例作为子类的原型
		特点:
			1 非常纯粹的继承关系，实例是子类的实例，也是父类的实例
			2 父类新增原型方法/原型属性，子类都能访问到
			3 简单，易于实现
		缺点：
			1 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中
			2 无法实现多继承
			3 来自原型对象的引用属性是所有实例共享的（详细请看附录代码： 示例1）
			4 创建子类实例时，无法向父类构造函数传参
			function Cat(){  }
			Cat.prototype = new Animal();
			Cat.prototype.name = 'cat';
			
			//　Test Code 测试部分 后面省略不写了 自己添加
			var cat = new Cat();
			console.log(cat.name);
			console.log(cat.eat('fish'));
			console.log(cat.sleep());
			console.log(cat instanceof Animal); //true 
			console.log(cat instanceof Cat); //true
			
	二 组合继承(推荐★★★★（仅仅多消耗了一点内存）)
		核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
		特点：
			1 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
			2 既是子类的实例，也是父类的实例
			3 不存在引用属性共享问题
			4 可传参
			5 函数可复用
		缺点：
			1 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）
			function Cat(name){
			  	Animal.call(this);
			  	this.name = name || 'Tom';
			}
			Cat.prototype = new Animal();
			
	三 寄生组合继承(推荐 ★★★★（实现复杂，扣掉一颗星）)		
		核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
		特点：
			堪称完美
		缺点：
			实现较为复杂
			function Cat(name){
			  	Animal.call(this);
			  	this.name = name || 'Tom';
			}
			(function(){
			  	// 创建一个没有实例方法的类
			  	var Super = function(){};
			  	Super.prototype = Animal.prototype;
			  	//将实例作为子类的原型
			  	Cat.prototype = new Super();
			})();
			
	四 构造函数(推荐★★ 缺点3)
		核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
		特点：
			1 解决了1中，子类实例共享父类引用属性的问题
			2 创建子类实例时，可以向父类传递参数
			3 可以实现多继承（call多个父类对象）
		缺点：
			1 实例并不是父类的实例，只是子类的实例
			2 只能继承父类的实例属性和方法，不能继承原型属性/方法
			3 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
			function Cat(name){
			  	Animal.call(this);
			  	this.name = name || 'Tom';
			}
			
	五 实例继承(推荐★★)
		核心：为父类实例添加新特性，作为子类实例返回
		特点：
			1 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果
		缺点：
			1 实例是父类的实例，不是子类的实例
			2 不支持多继承		
			function Cat(name){
			  	var instance = new Animal();
			  	instance.name = name || 'Tom';
			  	return instance;
			}
			
	六 拷贝继承(推荐★)		
		特点：
			1 支持多继承
		缺点：
			1 效率较低，内存占用高（因为要拷贝父类的属性）
			2 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到
			function Cat(name){
			  	var animal = new Animal();
			  	for(var p in animal){
			    	Cat.prototype[p] = animal[p];
			  	}
			  	Cat.prototype.name = name || 'Tom';
			}

#JavaScript创建对象的几种方式？
	说明:很多问题 都有很多方式解决 但常用的就一两种 对其他的几种只需要理解就好了
	
	1 对象字面量的方式{}  创建一个对象（最简单，好理解，推荐使用）
		var Cat  = {};//JSON
		Cat.name="kity";//添加属性并赋值
		Cat.age=2;
		Cat.sayHello=function(){
			alert("hello "+Cat.name+",今年"+Cat["age"]+"岁了");//可以使用“.”的方式访问属性，也可以使用HashMap的方式访问
		}
		Cat.sayHello();//调用对象的（方法）函数
	
	2 new方式创建对象 有参数 或无参数
		function Person(){ }
		var personOne=new Person();//定义一个function，如果有new关键字去"实例化",那么该function可以看作是一个类
		personOne.name="dylan";
		personOne.hobby="coding";
		personOne.work=function(){
			alert(personOne.name+" is coding now...");
		}
		personOne.work();
		
	3 使用工厂方式来创建（Object关键字）
		var wcDog =new Object();
		wcDog.name="旺财";
		wcDog.age=3;
		wcDog.work=function(){
		   alert("我是"+wcDog.name+",汪汪汪......");
		}
		wcDog.work();
		
	4 使用原型对象的方式  prototype关键字
		function Dog(){}
		Dog.prototype.name="旺财";
		Dog.prototype.eat=function(){
			alert(this.name+"是个吃货");
		}
		var wangcai =new Dog();
		wangcai.eat();
		
	5 混合模式(原型和构造函数)
		function Car(name,price){
		  	this.name=name;
		  	this.price=price; 
		}
		Car.prototype.sell=function(){
		   alert("我是"+this.name+"，我现在卖"+this.price+"万元");
		}
		var camry =new Car("凯美瑞",27);
		camry.sell();
		
	6 动态原型的方式(可以看作是混合模式的一种特例)
		function Car(name,price){
		  	this.name=name;
		  	this.price=price; 
		  	if(typeof Car.sell=="undefined"){
			   	Car.prototype.sell=function(){
			    	alert("我是"+this.name+"，我现在卖"+this.price+"万元");
			   	}
			 	Car.sell=true;
			  }
		}
		var camry =new Car("凯美瑞",27);
		camry.sell();

#iframe的优缺点
	优点：
		1.iframe能够原封不动的把嵌入的网页展现出来。
		2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
		3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
		4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。
	缺点：
		1.会产生很多页面，不容易管理。
		2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
		3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。
		4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。
		5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。
		分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。

#js延迟加载的方式有哪些？
	1 使用setTimeout延迟方法的加载时间
	2 让js最后加载(放在body底部)

#哪些操作会造成内存泄漏？ (比较重要)
	内存泄露: 一块被分配的内存既不能使用，也不能回收。从而影响性能，甚至导致程序崩溃。
	
	起因：JavaScript的垃圾自动回收机制会按一定的策略找出那些不再继续使用的变量，释放其占有的内存。
		然而由于一些原因导致在这种机制下内存管理器不能正确解读JavaScript变量的生命周期，从而没有释放其内存，而也没有再被使用。
		循环引用是导致以上情况的主要原因之一。
	 			
	1 全局变量过多
		:js中如果不用 var 声明变量,该变量将被视为 window 对象(全局对象)的属性,也就是全局变量.
		1)  function foo(arg) {
			    bar = "this is a hidden global variable";
			}
			// 上面的函数等价于  你调用完了函数以后,变量仍然存在,导致泄漏.
			function foo(arg) {
			    window.bar = "this is an explicit global variable";
			}
		2) 	function foo() {
			    this.variable = "potential accidental global";
			}
			// 没有对象调用foo, 也没有给它绑定this, 所以this是window
			foo();
			
	2 被遗忘的定时器或者回调
		var someResource = getData();
		setInterval(function() {
		    var node = document.getElementById('Node');
		    if(node) {
		        node.innerHTML = JSON.stringify(someResource));
		    }
		}, 1000);
		这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 
		因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放
	
	3 没有清理的DOM元素引用
		var elements = {
		    button: document.getElementById('button'),
		    image: document.getElementById('image'),
		    text: document.getElementById('text')
		};
		function doStuff() {
		    image.src = 'http://some.url/image';
		    button.click();
		    console.log(text.innerHTML);
		}
		function removeButton() {
		    document.body.removeChild(document.getElementById('button'));
		    // 虽然我们用removeChild移除了button, 但是还在elements对象里保存着#button的引用
		    // 换言之, DOM元素还在内存里面.
		}
	4 闭包 不在使用后清空(闭包我发现其实有很多问题 不好理解 见老师 我会在问 你自己也去查一查 这个很重要)
	
#数组方法数组方法pop() push() unshift() shift()
	Push()尾部添加 pop()尾部删除
	Unshift()头部添加 shift()头部删除
	
	push() 和 pop() 都是对末尾字符进行操作的 
		push()是尾部添加操作  pop()是尾部删除
		push()返回的是length pop()返回的是删出的字符
		
	unshift() 和  shift() 都是对首字符进行的操作
		unshift()是头部添加   返回的是length
		shift()首字符删除  返回值是删除的字符  

#解释jsonp的原理以及为什么不是真正的ajax？
	实现方法完全不一样。ajax的核心是通过XmlHttpRequest获取非本页内容，
		而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本。

#window.loction.search();返回的是什么？
	window.location.search方法是截取当前url中“?”后面的字符串， 
	例如：index.php?act=doctor,截取后的字符串就是act=doctor
	
	window.location 对象所包含的属性
	属性				描述
		hash			从井号 (#) 开始的 URL（锚）
		host			主机名和当前 URL 的端口号
		hostname		当前 URL 的主机名
		href			完整的 URL
		pathname		当前 URL 的路径部分
		port			当前 URL 的端口号
		protocol		当前 URL 的协议
		search			从问号 (?) 开始的 URL（查询部分

#JavaScript中的垃圾回收机制
	内存的生命周期
		1 当需要的时候分配内存
		2 对内存进行读写操作
		3 当上面分配的内存不再需要的时候，将他们释放掉
	过程:
		1 变量初始化(自动分配相应的内存空间)
		2 函数调用时候分配空间 
		3 操作变量值 读、写、函数调用
		4 内存不再被使用时，将它们释放掉
		5 垃圾回收

#精度问题：JS精度不能精确到0.1 
	console.log(0.1+0.2);	//结果为 0.30000000000000004
	
	原因: 
		其实对于浮点数的四则运算，几乎所有的编程语言都会有类似精度误差的问题，
		只不过在 C++/C#/Java 这些语言中已经封装好了方法来避免精度的问题，
		而 JavaScript 是一门弱类型的语言，从设计思想上就没有对浮点数有个严格的数据类型，
		所以精度误差的问题就显得格外突出
		
		计算机读懂的是二进制，而不是十进制，所以我们先把 0.1 和 0.2 转换成二进制结果为：
		0.1 => 0.0001 1001 1001 1001…（无限循环）
		0.2 => 0.0011 0011 0011 0011…（无限循环）
	
		双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串很长的二进制 0.0100110011001...
		因浮点数小数位的限制而截断二进制数字，这时候，我们再把它转换为十进制，就成了 0.30000000000000004。
	
	解决办法:给出明确的精度要求，在返回值的过程中，计算机会自动四舍五入
		Math.formatFloat = function(f, digit) { 
		    var m = Math.pow(10, digit); 
		    return parseInt(f * m, 10) / m; 
		} 
		var numA = 0.1; 
		var numB = 0.2;
		alert(Math.formatFloat(numA + numB, 1) === 0.3);

#计算字符串字节数
		var lenFor = function(str){	
	　　		var byteLen=0,len=str.length;
		　　	if(str){
		　　　　for(var i=0; i<len; i++){
		　　　　　　if(str.charCodeAt(i)>255){
		　　　　　　　　byteLen += 2;
		　　　　　　} else {
		　　　　　　　　byteLen++;
		　　　　　　}
		　　　　}
		　　　　return byteLen;
		　　	} else {
		　　　　return 0;
		　　	}
		}
		
	正则表达式检测字符串的字节长度：
		var lenReg = function(str){
		　　return str.replace(/[^x00-xFF]/g,'**').length;
		};

#BOM对象有哪些，列举window对象
	BOM:
		1. Window 对象：表示浏览器打开的窗口，包括获取焦点、改变滚动条、设置定时器等等。
		2. Navigator 对象：包含浏览器信息。如：获取浏览器名称、版本信息、操作系统平台信息等等。
		3. Screen 对象：包含屏幕信息。如：获取屏幕高度、宽度等等。
		4. History 对象：可对当前页的浏览历史进行操作，如：前进、后退等。
		5. Location 对象：可对当前页面的URL进行操作，如：导航到新的页面、获取URL信息等
		
	window: (举例一些常用的就行..)
		属性:
			closed	返回窗口是否已被关闭。
			defaultStatus	设置或返回窗口状态栏中的默认文本。
			document	对 Document 对象的只读引用。请参阅 Document 对象。
			history	对 History 对象的只读引用。请参数 History 对象。
			innerheight	返回窗口的文档显示区的高度。
			innerwidth	返回窗口的文档显示区的宽度。
			length	设置或返回窗口中的框架数量。
			location	用于窗口或框架的 Location 对象。请参阅 Location 对象。
			name	设置或返回窗口的名称。
			Navigator	对 Navigator 对象的只读引用。请参数 Navigator 对象。
			opener	返回对创建此窗口的窗口的引用。
			outerheight	返回窗口的外部高度。
			outerwidth	返回窗口的外部宽度。
			pageXOffset	设置或返回当前页面相对于窗口显示区左上角的 X 位置。
			pageYOffset	设置或返回当前页面相对于窗口显示区左上角的 Y 位置。
			parent	返回父窗口。
			Screen	对 Screen 对象的只读引用。请参数 Screen 对象。
			self	返回对当前窗口的引用。等价于 Window 属性。
			status	设置窗口状态栏的文本。
			top	返回最顶层的先辈窗口
		方法:
			alert()	显示带有一段消息和一个确认按钮的警告框。
			blur()	把键盘焦点从顶层窗口移开。
			clearInterval()	取消由 setInterval() 设置的 timeout。
			clearTimeout()	取消由 setTimeout() 方法设置的 timeout。
			close()	关闭浏览器窗口。
			confirm()	显示带有一段消息以及确认按钮和取消按钮的对话框。
			createPopup()	创建一个 pop-up 窗口。
			focus()	把键盘焦点给予一个窗口。
			moveBy()	可相对窗口的当前坐标把它移动指定的像素。
			moveTo()	把窗口的左上角移动到一个指定的坐标。
			open()	打开一个新的浏览器窗口或查找一个已命名的窗口。
			print()	打印当前窗口的内容。
			prompt()	显示可提示用户输入的对话框。
			resizeBy()	按照指定的像素调整窗口的大小。
			resizeTo()	把窗口的大小调整到指定的宽度和高度。
			scrollBy()	按照指定的像素值来滚动内容。
			scrollTo()	把内容滚动到指定的坐标。
			setInterval()	按照指定的周期（以毫秒计）来调用函数或计算表达式。
			setTimeout()	在指定的毫秒数后调用函数或计算表达式。

#js常用对象
	window
	document
	location
	History
	Navigator
	Screen
	Array
	Date
	Math
	RegExp

#解析url成一个对象
	var url = "http://www.taobao.com/index.php?key0=0&key1=1&key2=2";
	var obj = parseQueryString(url);
	function parseQueryString(argu){
	  var str = argu.split('?')[1];
	  var result = {};
	  var temp = str.split('&');
	  for(var i=0; i<temp.length; i++)
	  {
	     var temp2 = temp[i].split('=');
	     result[temp2[0]] = temp2[1];
	  }
	  return result;
	}

#已知有字符串foo = "get-element-by-id", 写一个function将其转化成驼峰命名表示法"getElementById"
			var o = {  
                trans:function (msg){  
                    var i,  
                    tempArr = msg.split('-'),  
                    len = tempArr.length;  
                    for(i = 1; i < len; i++){  
                        tempArr[i] = tempArr[i].charAt(0).toUpperCase()+tempArr[i].substr(1,tempArr[i].length-1);  
                    }  
                    msg = tempArr.join('');  
                    return msg;  
                }  
            };  
            o.trans('get-element-by-id'); 

#怎样添加  移除  复制  创建和查找节点
	创建新节点
      createDocumentFragment()    //创建一个DOM片段
      createElement_x()   //创建一个具体的元素
      createTextNode()   //创建一个文本节点
      
	添加、移除、替换、插入
      appendChild()
      removeChild()
      replaceChild()
      insertBefore()
      
	查找
      getElementsByTagName()    //通过标签名称
      getElementsByName()    //通过元素的Name属性的值
      getElementById()    //通过元素Id，唯一性

# 如何优化你的代码
	1代码重用
	2避免全局变量（命名空间，封闭空间，模块化mvc..）
	3拆分函数避免函数过于臃肿

#请说出三种减低页面加载时间的方法
	1、压缩css、js文件
	2、合并js、css文件，减少http请求
	3、外部js、css文件放在最底下
	4、尽量减少dom操作，尽可能用变量替代不必要的dom操作

#http协议中get和post有什么区别？分别适用什么场景？
	1 使用Get请求时,参数在URL中显示,而使用Post方式,则不会显示出来
	2 使用Get请求发送数据量小,Post请求发送数据量大
	查看这个地址具体使用:http://www.cnblogs.com/oneword/archive/2011/06/06/2073533.html

# 例举3种强制类型转换和2种隐式类型转换?
	强制（parseInt,parseFloat,number）
	隐式（== – ===）

# javascript的同源策略
	一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合

# 数组方法pop() push() unshift() shift()
	Push()尾部添加 pop()尾部删除
	Unshift()头部添加 shift()头部删除

# 添加 删除 替换 插入到某个接点的方法
	obj.appendChidl()
	obj.innersetBefore
	obj.replaceChild
	obj.removeChild

# javascript的本地对象，内置对象和宿主对象
	本地对象为array obj regexp等可以new实例化
	内置对象为gload Math 等不可以实例化的
	宿主为浏览器自带的document,window 等

#http中状态消息200 302 304 403 404 500分别表示什么？？
	五大类:
		100-199 用于指定客户端应相应的某些动作。
	　　200-299 用于表示请求成功。
			200: （成功）服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
			
	　　300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。
			302:（临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
			304:（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
			
	　　400-499 用于指出客户端的错误。
			403:（禁止） 服务器拒绝请求
			404:（未找到） 服务器找不到请求的网页。
			
	　　500-599 用于支持服务器错误。
			500:（服务器内部错误） 服务器遇到错误，无法完成请求。


#解释什么是sql注入，xss漏洞
	SQL:当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击，如查询、插入数据时。
	xss:通过插入恶意脚本，实现对用户浏览器的控制

#列举长用的js框架以及分别适用放入领域
	web开发:
		jquery.js : 很常用
		angularjs: web单页面开发
	移动开发:
		Zepto.js: 类似jq 体积小巧 多了一些触摸屏的事件 ;
		vue.js: 分割版angularjs 同样 体积小巧 
		
#在JavaScript中什么是伪数组？如何将伪数组转化为标准数组
	什么是伪数组:不能调用数组内置的一些属性和方法的数组(也就是假的 张的想而已) 
	例如:
		这种对象有很多，比较特别的是arguments对象，还有像调用getElementsByTagName,document.childNodes之类的，
		它们都返回NodeList对象都属于伪数组。 
	转化:
		能通过Array.prototype.slice转换为真正的数组 带有length属性的对象。 
		我们可以通过Array.prototype.slice.call(fakeArray)将伪数组转变为真正的Array对象。
		
		var fakeArray01 = {0:'a',1:'b',length:2};//这是一个标准的有伪数组对象 
		var arr01 = Array.prototype.slice.call(fakeArray01); 
		alert(arr01[0]);//a 
		var arr02 = [].slice.call(fakeArray01); 
		alert(arr02[0]);//a 

#列举哪些方法对前端开发进行优化？
	优化的目的:
		1 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。   
		2 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。
	
	优化方法:
		http请求过程:一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个“漫长”而复杂的过程
		1 减少HTTP请求数
			使用图片地图
			使用CSS Sprites
			合并JS和CSS文件		
		2 使用CDN(内容发布网络):当页面中有很多资源的时候,可以从不同的服务中去读取,同时可以提高并行下载速度
		3 添加http Expires头:为图片视频之类很少改变的资源设置长的Expires时间将直接减少http请求
			如果资源设置了Expires头为将来的某个时间,下次访问时候浏览器发现资源还没有过期,会直接从缓存中读取,不会再次产生http请求
		4.压缩组件:在Server端对Response资源进行压缩再传给浏览器,一般使用GZIP
		5.将CSS放再顶部: 能加快页面内容显示,并且能避免页面产生白屏
		6.将JS放在底部
		JS会阻塞对其后面内容的呈现
		JS会阻塞对其后面内容的下载
		7.避免CSS表达式
		8.将JS,CSS放在外部文件中
		9.通过使用Keep-Alive和较少的域名来减少DNS查找
		10.精简JS和CSS文件
		11.寻找一种避免重定向的方法
		12.移除重复的脚本
		13.配置Etag
	
	总结:优化这种东西 比较续 纯靠经验(自己在多去 看看 需要理解)

#程序中异常捕获的方法
	try{ 
		...some code... 
	}catch(e){ 
		...some code... //处理错误 
		throw(e.name); //抛出异常 
	}finally{
		　　　　// 完成后执行的语句块，非必须
	}
	
	javascript Error 对象：
	name: 错误名称
	number: 错误号
	description: 描述信息 
	message: 错误信息 
	fileName: 错误发生的文件 
	stack: 错误发生时的调用堆栈
	

#请说出三种减低页面加载时间的方法
	1、压缩css、js文件
	2、合并js、css文件，减少http请求
	3、外部js、css文件放在最底下
	4、尽量减少dom操作，尽可能用变量替代不必要的dom操作

# 如何优化你的代码 
	1代码重用
	2避免全局变量（命名空间，封闭空间，模块化mvc..）
	3拆分函数避免函数过于臃肿

#AJAX 工作原理
	请尽可能详尽的解释AJAX的工作原理。
	/*创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）
	判断数据传输方式(GET/POST)
	打开链接 open()
	发送 send()
	当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数*/

# 简述同步和异步的区别
	javascript: 是单线程机制。所谓单线程就是按次序执行，执行完一个任务再执行下一个。
		对于浏览器来说，也就是无法在渲染页面的同时执行代码。
		单线程机制的优点在于实现起来较为简单，运行环境相对简单。
		缺点在于，如果中间有任务需要响应时间过长，经常会导致
		页面加载错误或者浏览器无响应的状况。这就是所谓的“同步模式”，程序执行顺序与任务排列顺序一致。对于浏览器来说，
		同步模式效率较低，耗时长的任务都应该使用异步模式；而在服务器端，异步模式则是唯一的模式，如果采用同步模式个人认为
		服务器很快就会出现12306在高峰期的表现。。。。

	同步: 阻塞模式 就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，
			那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；
	异步: 非阻塞模式 是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。
			当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。
		例如;
			1)回调函数callback
				所谓回调函数，就是将函数作为参数传到需要回调的函数内部再执行。
				典型的例子就是发送ajax请求。例如：
				     $.ajax({
					    async: false, 
					    cache: false,
					    dataType: 'json',
					    url: "url",
					    success: function(data) {
					      console.log('success');
					    },
					    error: function(data) {
					     console.log('error');
					    }
					  })
					当发送ajax请求后，等待回应的过程不会堵塞程序运行，耗时的操作相当于延后执行。
					回调函数的优点在于简单，容易理解，但是可读性较差，耦合度较高，不易于维护。
					
			2)事件驱动
				javascript可以称之为是基于对象的语言，而基于对象的基本特征就是事件驱动（Event-Driven）。
				事件驱动，指的是由鼠标和热键的动作引发的一连串的程序操作。
				例如，为页面上的某个绑定click事件；
				$('#btn').onclick(function(){
				   console.log('click button');
				});
				绑定事件相当于在元素上进行监听，是否执行注册的事件代码取决于事件是否发生。
				优点在于容易理解，一个元素上可以绑定多个事件，有利于实现模块化；
				但是缺点在于称为事件驱动的模型后，流程不清晰。

# javascript的typeof返回哪些数据类型
	Object number function boolean underfind

# 例举3种强制类型转换和2种隐式类型转换?
	强制（parseInt,parseFloat,number）
	隐式（== – ===）

# split() join() 的区别
	前者是切割成数组的形式，后者是将数组转换成字符串
###	split()
	<script type="text/javascript">
		"2:3:4:5".split(":")	//将返回["2", "3", "4", "5"]
		"|a|b|c".split("|")	//将返回["", "a", "b", "c"]
	</script>	
	返回值：一个字符串数组

###	join()
	<script type="text/javascript">
	
		var arr = new Array(3)
		arr[0] = "George"
		arr[1] = "John"
		arr[2] = "Thomas"
		
		document.write(arr.join())
		
	</script>
	输出：
		George,John,Thomas
	返回值：返回一个字符串	
	

# 数组方法pop() push() unshift() shift()
	Push()尾部添加 pop()尾部删除
	Unshift()头部添加 shift()头部删除

	push() 和 pop() 都是对末尾字符进行操作的 
		push()是尾部添加操作  pop()是尾部删除
		push()返回的是length pop()返回的是删出的字符
	unshift() 和  shift() 都是对首字符进行的操作
		unshift()是头部添加   返回的是length
		shift()首字符删除  返回值是删除的字符  


# 事件绑定和普通事件有什么区别
	onclick,oncketup. 普通事件 事件会覆盖
	addeventListener. 事件监听 事件不会覆盖

	普通事件 也就是传统事件绑定  简单稳定  很好的解决了兼容问题
	在处理事件时  用的是this  引用的是当前元素
	例如  onclick事件
	为什么说 它有利于浏览器的兼容性呢
	因为  ie 它就只支持  冒泡  不支持  捕获事件  
	而 DOM事件流  它既支持捕获事件  又支持  冒泡事件   它是先捕获后冒泡的
	
	传统的方法 它就只会在事件冒泡的时候运行 而非捕获和冒泡
	传统的事件绑定 它一个元素只能绑定一个处理函数，如果你绑定两个
	那么新绑定的会把之前绑定的事件覆盖掉
	它还有一个问题呢  就是  你在绑定事件时  例如element.onclick = function(e){}
	function中本来是可以传参的    但是我传了参数后  它在ie中是不生效的  你打印出来就是undefined 
	
	两种事件流  都会触及DOM中的所有对象  从document开始也在document结束
	
	不同的是  
		DOM事件流中 文本节点也触发事件
		这个是DOM独特的特质
		ie中不会
	    

	事件绑定呢就是w3c绑定  ie8及以下版本是不支持的  
	在ie8及一下的版本中你必须使用IE的attachEvent这个函数来代替
	ie9是支持的
	Element.eleEventListenner(什么事件，事件处理函数，boolean)
	bool---true   事件在捕获阶段执行
	bool---false    事件在冒泡阶段执行     默认值
	
	对应的有
	可以用 removeEventListener() 方法来移除 addEventListener() 方法。

# IE和DOM事件流的区别
	1.执行顺序不一样、
	2.参数不一样
		事件侦听函数的区别
			ie-->attachEvent('事件',事件处理函数);//两个参数
			DOM-->addEventListener('事件'，事件处理函数,boolean);//三个参数			
	3.事件加不加on
	4.this指向问题
	5 ie 捕获 html>div>button
	  dom 先捕获 在 冒泡  html>div>button>div>html

# IE和标准下有哪些兼容性的写法
	Var ev = ev || window.event
	document.documentElement.clientWidth || document.body.clientWidth
	Var target = ev.srcElement||ev.target

# ajax请求的时候get 和post方式的区别
	1 使用Get请求时,参数在URL中显示,而使用Post方式,则不会显示出来
	2 使用Get请求发送数据量小,Post请求发送数据量大
	查看这个地址具体使用:http://www.cnblogs.com/oneword/archive/2011/06/06/2073533.html

# call和apply的区别
	Object.call(this,obj1,obj2,obj3)
	Object.apply(this,arguments)

# 事件委托是什么
	让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！
	案例: 为ui添加li 后添加的li没有事件 
		
		
# 闭包是什么，有什么特性，对页面有什么影响
	闭包: 闭包的实质是一个函数，是一个用于返回局部变量值的函数，
	闭包特性 : 是能够读取其他函数内部变量的函数 因为在全局中，受JavaScript链式作用域结构的影响，父级变量中无法访问到子级的变量值，为了解决这个问题，才使用闭包这个概念。
	影响: 由于闭包时，变量的值都保存到内存中，会导致页面加载时内存消耗很大，IE会导致内在泄露，因此尽量少用或用时要及时删除变量。
	例如:
		//问题代码	
		for(var i = 0 ; i < 10; i++){
          setTimeout(function(){
              console.log(i);
          },0);
      	}
        //闭包解决问题的代码
        for(var i = 0; i< 3; i++){
            function foo(j){
                return function(){
                    console.log(j);
                };
            }
            var f = foo(i);
            setTimeout(f, 0);
        }

# 如何阻止事件冒泡和默认事件
	canceBubble return false
	// 停止事件冒泡
	function stopBubble(e) {
	    // 如果提供了事件对象，则这是一个非IE浏览器
	    if ( e && e.stopPropagation ) {
	        // 因此它支持W3C的stopPropagation()方法 
	        e.stopPropagation();
	    } else { 
	        // 否则，我们需要使用IE的方式来取消事件冒泡
	        window.event.cancelBubble = true;
	    }
	}    
	// 阻止事件默认行为
	function stopDefault( e ) {
	     // 阻止默认浏览器动作(W3C)
	     if ( e && e.preventDefault ) {
	         e.preventDefault();
	     } else {
	        // IE中阻止函数器默认动作的方式
	        window.event.returnValue = false;
	    }
	    return false;

# 添加 删除 替换 插入到某个接点的方法
	obj.appendChidl()
	obj.innersetBefore
	obj.replaceChild
	obj.removeChild

# javascript的本地对象，内置对象和宿主对象
	本地对象为array obj regexp等可以new实例化
	内置对象为gload Math 等不可以实例化的
	宿主为浏览器自带的document,window 等

# 解释jsonp的原理，以及为什么不是真正的ajax
	Ajax是页面无刷新请求数据操作
	
	动态创建script标签，回调函数
	1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；
	2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本。
	3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。
	4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。
	总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！

# ”==”和“===”的不同
	==: 比较值是否相同      前者会自动转换类型
	===: 比较值与数据类型是否相同     后者不会

# javascript的同源策略
	一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合

# 函数打印结果 (题比较逗逼 但是 非常考研js的基础)
	function Foo() {
	    getName = function () { alert (1); };
	    return this;
	}
	Foo.getName = function () { alert (2);};
	Foo.prototype.getName = function () { alert (3);};
	var getName = function () { alert (4);};
	function getName() { alert (5);}
	
	1) Foo.getName();//2
	
	2) getName();//4 (俩个容易遗忘点 变量声明提升，二是函数表达式)
		例子:
			console.log('x' in window);//true
			var x;
			x = 0;
				变量声明提升
				var x;
				console.log('x' in window);//true
				x = 0;
			-------------------------------------
			console.log(x);//输出：function x(){}
			var x=1;  // 拆分为 var x; 和 x = 1;
			function x(){} //拆分为 var x; 和 function x(){} 
				函数表达式
				var x;
				function x(){} //所以最终函数声明的x覆盖了变量声明的x，log输出为x函数
				console.log(x);
				x=1;
		---------------------------------------
		
		var getName;
		function getName() { alert (5);} //函数直接提升
		function Foo() {
		    getName = function () { alert (1); };
		    return this;
		}
		Foo.getName = function () { alert (2);};
		Foo.prototype.getName = function () { alert (3);};
		getName = function () { alert (4);}; //变量声明提升 所以打印4
											 //函数直接提升
	
	3) Foo().getName();//1
		
	4) getName();//1
	
	5) new Foo.getName();//2 
		.的优先级高于new 所以相当于 new (Foo.getName())
		
	6) new Foo().getName();//3
		构造函数的返回值问题
			在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。 而在js中构造函数可以有返回值也可以没有。
			1、没有返回值则按照其他语言一样返回实例化对象。
				function F(){}
				new F()
				f{}
			2   若有返回值则检查其返回值是否为引用类型。如果是非引用类型，
				如基本类型（string,number,boolean,null,undefined）则与无返回值相同，实际返回其实例化对象。
				function F(){return true;}
				new F()
				F{}
			3 若返回值是引用类型 则实际返回值为这个引用类型
				function F(){return {a:1};}
				new F()
				object{a:1}
			
		(new Foo()).getName()
			原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。
			之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName，找到了。
			
	7) new new Foo().getName();//3
		new ((new Foo()).getName)();
		先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new。

## JS的部分兼容写法
##### 认识DOM0级方法跟DOM2级方法
DOM0就是直接通过 onclick写在html里面的事件, 比如:
```
<input onclick="alert(1)" />
```
 DOM2是通过addEventListener绑定的事件, 还有IE下的DOM2事件通过attachEvent绑定;


①添加事件方法
* addEventListener(type,handler,false)方法用于向指定元素添加事件句柄 

 三个参数分别是：

  * event:必传,
字符串,指定事件名。
注意: 不要使用 "on" 前缀。 例如，使用 "click" ,而不是使用 "onclick"。
提示: 所有 HTML DOM 事件; 
  * function:必传。指定要事件触发时执行的函数。 当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， "click" 事件属于 MouseEvent(鼠标事件) 对象 
  * useCapture:可选，是否在捕获或冒泡阶段执行 为bool值

```
addHandler：function(element,type,handler){
 if(element.addEventListener){//检测是否为DOM2级方法
 element.addEventListener(type, handler, false);
 }else if (element.attachEvent){//检测是否为IE级方法
 element.attachEvent("on" + type, handler);
 } else {//检测是否为DOM0级方法
 element["on" + type] = handler;
 }
}


```
②移除之前添加的事件方法
```
removeHandler：function(element, type, handler){ 
 if (element.removeEventListener){     element.removeEventListener(type, handler, false);
 } else if (element.detachEvent){
 element.detachEvent("on" + type, handler);
 } else {
 element["on" + type] = null;
 }
}
```
③获取事件及事件对象目标

 获取事件对象的兼容性写法
```
getEvent: function(event){

   return event ? event : window.event;

}

```
获取事件对象目标的兼容性写法
```
getTarget: function(event){
   return event.target || event.srcElement;
 }

```

④阻止浏览器默认事件的兼容性写法
```
preventDefault: function(event){ 
    if (event.preventDefault){ 
        event.preventDefault();
 } else { 
        event.returnValue = false;
 } }

```



⑤阻止事件冒泡的兼容性写法
```
stopPropagation: function(event){ 
if (event.stopPropagation){ 
     event.stopPropagation();
 } else { 
     event.cancelBubble = true;
 } }

```
⑥mouseover和mouseout 事件才包含的获取相关元素的方法

//mouseover和mouseout 事件才包含的获取相关元素的方法getRelatedTarget: function(event){ if (event.relatedTarget){ return event.relatedTarget; } else if (event.toElement){ return event.toElement; } else if (event.fromElement){ return event.fromElement; } else { return null; }}

⑦鼠标滚轮判断

对于mousedown 和mouseup 事件来说，则在其event 对象存在一个button 属性，表示按下或释放的按钮。

1. DOM的button 属性可能有如下3 个值：
  * 0 表示主鼠标按钮，
  * 1 表示中间的鼠标按钮（鼠标滚轮按钮），
  * 2 表示次鼠标按钮。

2. 在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标按钮就是鼠标右键。IE8 及之前版本也提供了button 属性，但这个属性的值与DOM 的button 属性有很大差异.
  * 0：表示没有按下按钮。
  * 1：表示按下了主鼠标按钮。
  * 2：表示按下了次鼠标按钮。
  * 3：表示同时按下了主、次鼠标按钮。
  * 4：表示按下了中间的鼠标按钮。
  * 5：表示同时按下了主鼠标按钮和中间的鼠标按钮。
  * 6：表示同时按下了次鼠标按钮和中间的鼠标按钮。
  * 7：表示同时按下了三个鼠标按钮。
```
getButton: function(event){
  if(document.implementation.hasFeature("MouseEvents", "2.0")){
 return event.button;
 } else {
 switch(event.button){
 case 0: 
 case 1: 
 case 3: 
 case 5:
 case 7:
 return 0;
 case 2:
 case 6:
 return 2;
 case 4:
 return 1;
  }
 }
}
```

⑧能够取得鼠标滚轮增量值（delta）的方法
```
getWheelDelta: function(event){
  if (event.wheelDelta){
 return (client.engine.opera && client.engine.opera < 9.5 ? -  event.wheelDelta : event.wheelDelta);
 } else {
  return -event.detail * 40;//firefox中的值为+3表示向上滚，-3表示向下滚 }}

```


⑨跨浏览器的方式取得字符编码
```
getCharCode: function(event){
 if (typeof event.charCode == "number"){
 return event.charCode;
 } else {
 return event.keyCode;
 }
}

```


⑩访问剪贴板中的数据
```
getClipboardText: function(event){
 var clipboardData = (event.clipboardData || window.clipboardData);
 return clipboardData.getData("text");
 }

```


11.设置剪贴板中的数据
```
setClipboardText: function(event, value){
 if (event.clipboardData){ 
return event.clipboardData.setData("text/plain", value);
 } else if (window.clipboardData){
 return window.clipboardData.setData("text", value);
 }
}

```

#Html5
	是html4的升级版
	是最新的HTML标准
	是专门为承载丰富的web内容而设计的，
	并且无需额外插件。提供所有内容而不需要任何的像flash，silverlight等的额外插件
	
	拥有新的语义、图形以及多媒体元素
	
	HTML5提供新的元素和新的API简化了web应用程序的搭建
	
	HTML5是跨平台的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等之上运行）
	

#应用:
	制定了Web应用开发的一系列标准，成为第一个将Web作为应用开发平台的HTML语言。
	如新语义标签、智能表单、多媒体标签等。

#CSS3
	CSS3完全向后兼容，因此不必改变现有设计。浏览器通常支持css2。
	CSS3被划分为模块，最重要的css3模块包括：
		选择器
		框模型
		背景和边框
		文本效果
		2D/3D转换
		动画
		多列布局
		用户界

#应用	
	1.颜色：新增RGBA,HSLA模式
	2.文字阴影 test-shadow
	3.边框：圆角 border-radius，边框阴影：box-shadow
	4.盒子模型：box-sizing
	5.背景：background-size设置背景图片的尺寸
		  background-origin设置北京图片的原点
		  background-clip设置背景图片的裁切区域，以“,”
		      分隔可以设置背景，用于自适应布局
	6.渐变：linear-gradient、radial-gradient
	7.过渡：transition，可实现动画
	8.自定义动画
	9.在CSS3中唯一引入的伪元素是::selection
	10.媒体查询，多栏布局
	11.border-imag
	12.2D转换：transform：translate(x,y)
							roate(x,y)
							skew(x,y)
							scale(x,y)··
	13.3D转换					
#jQuery
	jquery是js的一个库，封装了我们开发过程中常用的一些功能，方便我们来调用，提高了我们的开发效率。

#应用：
	使用jquery操作DOM，其实就是学习jquery封装好的那些功能方法这些方法叫API。
	这些API的共同特点是：几乎全都是方法。所以，在使用jquery的API时都是方法调用也就是说要加小括号（），
	小括号里是相应的参数，参数不同功能不同
#jqury的使用：
	1.引包
	2.入口函数
	3.功能代码（事件处理）

#ajax	
	原理：
	1.通过异步模式提升了用户体验
	2.优化了浏览器和服务器之间的传输，减少不必要的数据往返减少了带宽占用
	3.ajax在用户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
	Ajax不是一门新的语言，而是对现有技术的综合利用。
	本质是在HTTP协议基础上的以异步的方式与服务器进行通信。
	
	应用：
	1、创建XMLHttpRequest对象，也就是创建一个异步调用对象
	2、创建一个新的HTTP请求，并指定该HTTP请求的方法，URL及验证信息
	3、设置响应Http请求状态变化的函数
	4、发送HTTP请求
	5.异步获取调用返回的数据
	6.使用javascript和DOM实现DOM的局部刷新
	
	Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据节约带宽资源。

#jsonp
	要点：动态创建script标签，回调函数、
	
	协议、域名、端口都相同才同域，否则都是跨域
	出于安全考虑，服务器不允许用ajax跨域获取数据，但是可以跨域获取文件内容，
	所以基于这一点可以动态创建script标签，使用src属性访问js文件的形式获取js脚本，
	并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，
	为了获取这里参数的数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，
	这就是解决跨域问题的主流解决方案
	
	同源策略是浏览器的一种安全策略，所谓同源是指->域名  端口   协议完全 相同。
	其本质是利用了<script src = ""></script>标签具有可跨域的特性，由服务端返回一个预先定义好的jabascript函数的调用，
	并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合才能完成。

#应用
	1.动静分离时用到jsonp
	2.接口开了但用不了时用jsonp

#Node.js
	Node.js是一个构建于 谷歌的Chrome浏览器的v8引擎之上的一个javascript运行时的环境
	Node.js可以解析和执行javascript代码

#应用
	node是js运行环境下基于v8引擎
	特点用事件驱动、无阻塞的io模型
	优势轻量、高效
#anjular.js
	Anjularjs是一款由Google公司开发维护的前端MVC框架，其克服了HTML在构建应用上的诸多不足，
	从而降低了开发成本提升了开发效率。anjularjs是一个框架（诸多类库的集合）以数据和逻辑作为驱动（核心）。
#应用
	单页面应用
#Bootstrap
	bootstrp是最受欢迎的Html、CSS和js框架
#应用
	用于响应式开发布局，移动设备优先的WEB项目
#面向对象
	面向对象是一种思维方式，是将问题的关注点放到解决问题所需要的一系列对像上。
	面向过程是一种思维方式，是将解决问题的关注点放到解决问题的详细步骤上。
#应用
	面向对象是对面向过程的封装
#闭包
	一个封闭的对外不公开的，包裹结构，或者空间。
#作用：
	闭包的作用，就是保存自己私有的变量，通过提供接口（方法）给外部使用，但外部不能直接访问该变量。
	外部空间想要访问函数内部的数据，只能通过闭包提供的指定方法，
	在这个方法内部可以设置一些校验规则，让函数变得更加的安全。
	1.写一个函数，函数内部定义一个新函数，并返回新函数，用新函数获取函数内的数据。
	2.写一个函数，函数内定义一个对象，对象中绑定一个函数（方法），
	  返回对像，利用对象的方法访问函数内部数据。

1.函数   内部定义新函数   并返回新函数  用新函数获取函数内部的数据
2.函数   内部定义对象   对象中绑定一个函数  返回对象  利用对象的方法访问函数内部数据

#原型链
	每个构造函数都有一个原型对象，
	每个对象都有构造函数。
	每个构造函数的原型对象都是对象，也就是构造函数
	然后就形成一个链式的结构，我们称之为原型链

#应用：
	javascript是面向对象的，每个实例对象都有一个__proto__属性，该属性指向它原型对象，
	这个实例对象的的构造函数有一个原型属性prototype，与实例的__proto__属性指向同一个对象
	当一个对象在查找一个属性时，如果自身没有的话就根据__proto__像它的原型进行查找，
	如果都没有，像它原型的原型继续查找，直到查找到Object.prototype.__proto__为null
	这样就形成了原型链。



	**备注：**

```
根据自己需求选择性阅读，前端的路上我们一起携手共进！
个人收藏有不少关于前端开发的书籍以及资料，如有需要，请通过邮箱索要！
```

​	
©[杨方涛](https://github.com/famensaodiseng)   		

Email:58267980@qq.com
